#include "Edge.hpp"
//#include "Dep/IIR/IIRDecimator.h"
//#include "Dep/IIR/IIRUpsampler.h"
#include "Dep/LambertW.hpp"
#include "dsp/resampler.hpp"


inline float clip(float x) {
	return tanhf(x);
}






struct MyasmaDist : Module {
	enum ParamIds {
		FEEDBACK_PARAM,
		GAIN_PARAM,
		BLEND_PARAM,
		CV_GAIN_PARAM,
		CV_FEEDBACK_PARAM,
		NUM_PARAMS
	};
	enum InputIds {
		CV_GAIN_INPUT,
		IN_INPUT,
		CV_FEEDBACK_INPUT,
		FEEDBACK_INPUT,
		NUM_INPUTS
	};
	enum OutputIds {
		OUT_OUTPUT,
		FEEDBACK_OUTPUT,
		NUM_OUTPUTS
	};
	enum LightIds {
		NUM_LIGHTS
	};


    Upsampler<2,2> Upsample;
    Decimator<2,2> Decimate;
    float Ov_Buffer[2] = {};

	float buff[44100]={0};
	float state[4]{0};
	float omega0;
	float last_step = 0.0f;


	//*******************
    const float m_thermalVoltage = 0.025864f;
	const float m_saturationCurrent = 10e-17f;
	float m_resistor = 15000.f;
	float m_loadResistor = 7500.f;
	float m_loadResistor2 = m_loadResistor * 2.f;
	// Derived values
	float m_alpha = m_loadResistor2 / m_resistor;
	float m_beta = (m_resistor + m_loadResistor2) / (m_thermalVoltage * m_resistor);
	float m_delta = (m_loadResistor * m_saturationCurrent) / m_thermalVoltage;

	//********************


	MyasmaDist() : Module(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS) {
	}



	void step() override;

	// For more advanced Module features, read Rack's engine.hpp header file
	// - toJson, fromJson: serialization of internal data
	// - onSampleRateChange: event triggered by a change of sample rate
	// - onReset, onRandomize, onCreate, onDelete: implements special behavior when user clicks these from the context menu
};





void MyasmaDist::step() {


    float result = 0.0f;
    float feedback = params[FEEDBACK_PARAM].value;

    float gain = clamp(params[GAIN_PARAM].value+(inputs[CV_GAIN_INPUT].value/5*params[CV_GAIN_PARAM].value),0.0f,6.0f);
    float in =inputs[IN_INPUT].value/5.0f*1.2;

    buff[0]=in;

    for(int i = 905 ; i >= 0 ; i--){
        buff[i+1]=buff[i];
    }

    if(inputs[FEEDBACK_INPUT].active){
        in += feedback*inputs[FEEDBACK_INPUT].value/5;
    }
    else{
        in += feedback*buff[280]/2;
    }
    in*=gain;



    in = tanh(in);
    const float theta = sgn(in);
    //UPSAMPLE

    Upsample.process(in,Ov_Buffer);

    for (int i = 0; i < 2; i++) {
        Ov_Buffer[i] =  m_alpha*Ov_Buffer[i] - (theta * m_thermalVoltage * LambertW(m_delta * exp(theta * m_beta * Ov_Buffer[i])));
    }

    result = Decimate.process(Ov_Buffer);





    result = m_alpha*in - (theta * m_thermalVoltage * LambertW(m_delta * exp(theta * m_beta * in))) ;


    //DOWNSAMPLE


    outputs[OUT_OUTPUT].value = tanh(result)*20;
    outputs[FEEDBACK_OUTPUT].value = tanh(result)*20;

    last_step = tanh(result);



}


struct MyasmaDistWidget : ModuleWidget {
	MyasmaDistWidget(MyasmaDist *module) : ModuleWidget(module) {
		setPanel(SVG::load(assetPlugin(plugin, "res/MyasmaDist.svg")));

		addChild(Widget::create<ScrewSilver>(Vec(RACK_GRID_WIDTH, 0)));
		addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, 0)));
		addChild(Widget::create<ScrewSilver>(Vec(RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
		addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));

		addParam(ParamWidget::create<RoundHugeBlackKnob>(Vec(33, 61), module, MyasmaDist::FEEDBACK_PARAM, 0.01, 5.0, 0.0));
		addParam(ParamWidget::create<RoundLargeBlackKnob>(Vec(12, 143), module, MyasmaDist::GAIN_PARAM, 0, 2.0, 0.3));
		addParam(ParamWidget::create<RoundLargeBlackKnob>(Vec(71, 143), module, MyasmaDist::BLEND_PARAM, 0, 1.0, 1.0));
		addParam(ParamWidget::create<RoundLargeBlackKnob>(Vec(12, 208), module, MyasmaDist::CV_GAIN_PARAM, -1.0, 1.0, 0.0));
		addParam(ParamWidget::create<RoundLargeBlackKnob>(Vec(71, 208), module, MyasmaDist::CV_FEEDBACK_PARAM, -1.0, 1.0, 0.0));

		addInput(Port::create<PJ301MPort>(Vec(10, 276), Port::INPUT, module, MyasmaDist::CV_GAIN_INPUT));
		addInput(Port::create<PJ301MPort>(Vec(48, 276), Port::INPUT, module, MyasmaDist::IN_INPUT));
		addInput(Port::create<PJ301MPort>(Vec(85, 276), Port::INPUT, module, MyasmaDist::CV_FEEDBACK_INPUT));
		addInput(Port::create<PJ301MPort>(Vec(10, 320), Port::INPUT, module, MyasmaDist::FEEDBACK_INPUT));

		addOutput(Port::create<PJ301MPort>(Vec(48, 320), Port::OUTPUT, module, MyasmaDist::OUT_OUTPUT));
		addOutput(Port::create<PJ301MPort>(Vec(85, 320), Port::OUTPUT, module, MyasmaDist::FEEDBACK_OUTPUT));

	}
};


// Specify the Module and ModuleWidget subclass, human-readable
// author name for categorization per plugin, module slug (should never
// change), human-readable module name, and any number of tags
// (found in `include/tags.hpp`) separated by commas.
Model *modelMyasmaDist = Model::create<MyasmaDist, MyasmaDistWidget>("Edge", "MyasmaDist", "MyasmaDist", OSCILLATOR_TAG);
